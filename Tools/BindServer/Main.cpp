#define WIN32_MEAN_AND_LEAN
#include <WinSock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdint.h>

#pragma comment(lib, "ws2_32.lib")

//#define TARGET_PORT 9001

int32_t wmain(int32_t nArgc, const wchar_t *pArgv[]) {
    WSADATA WsaData = { 0 };

    if (nArgc < 2) {
        printf("... usage: %ws <port to bind> <optional: file to serve>\r\n", pArgv[0]);
    }
    else {
        int32_t nTargetPort = _wtoi(pArgv[1]);
        const wchar_t *FilePath = nullptr;

        if (nArgc >= 3) {
            FilePath = pArgv[2];
        }

        printf("... binding port %d to serve file %ws\r\n", nTargetPort, FilePath == nullptr ? L"N/A" : FilePath);

        if ((WSAStartup(0x202, &WsaData)) == 0) {
            struct sockaddr_in LocalSin = { 0 };
            SOCKET ListenerSock;
            HANDLE hFile;
            uint8_t* pFileBuf = nullptr;
            uint32_t dwFileSize = 0;

            if (FilePath != nullptr) {
                if ((hFile = CreateFileW(FilePath, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr)) != INVALID_HANDLE_VALUE) {
                    uint32_t dwBytesRead = 0;
                    dwFileSize = GetFileSize(hFile, nullptr);
                    pFileBuf = (uint8_t*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize + 1);
                    ReadFile(hFile, pFileBuf, dwFileSize, reinterpret_cast<PDWORD>(&dwBytesRead), nullptr);
                    printf("... successfully read %d bytes from %ws (size on disk: %d)\r\n", dwBytesRead, FilePath, dwFileSize);
                    CloseHandle(hFile);
                }
                else {
                    printf("... failed to read data from file %ws\r\n", FilePath);
                    return 0;
                }
            }

            LocalSin.sin_family = AF_INET;
            LocalSin.sin_addr.s_addr = INADDR_ANY;
            LocalSin.sin_port = htons(nTargetPort);

            ListenerSock = socket(AF_INET, SOCK_STREAM, 0);

            if (ListenerSock != INVALID_SOCKET) {
                if (bind(ListenerSock, (struct sockaddr*)&LocalSin, sizeof(LocalSin)) != SOCKET_ERROR) {
                    printf("... bound port %d on server. Listening...\r\n", nTargetPort);

                    if (listen(ListenerSock, 5) != SOCKET_ERROR) {
                        while (1) {
                            struct sockaddr_in ClientSin = { 0 };
                            int nSinSize = sizeof(ClientSin);
                            SOCKET ClientSock = accept(ListenerSock, (struct sockaddr*)&ClientSin, &nSinSize);

                            if (ClientSock != INVALID_SOCKET) {
                                printf("... accepted connection from new client...\r\n");
                                char Buffer[10000] = { 0 };
                                int32_t retval = recv(ClientSock, Buffer, sizeof(Buffer), 0);

                                if (retval != SOCKET_ERROR) {
                                    if (retval == 0) {
                                        printf("Server: Client closed connection.\n");
                                        closesocket(ClientSock);
                                        continue;
                                    }

                                    printf("... received %d bytes:\r\n%s\r\n", retval, Buffer);

                                    if (dwFileSize) {
                                        uint32_t dwResponseBufSize = 5000 + dwFileSize;
                                        char* pResponseBuf = static_cast<char *>(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwResponseBufSize));
                                        
                                        sprintf_s(pResponseBuf, dwResponseBufSize, 
                                            "HTTP/1.1 200 OK\r\n"
                                            "Content-type: text/html\r\n"
                                            "Content-Length: %d\r\n\r\n%s", dwFileSize, pFileBuf);

                                        if (send(ClientSock, pResponseBuf, strlen(pResponseBuf), 0)) {
                                            printf("... successfully sent %d byte response to remote client:\r\n%s\r\n", strlen(pResponseBuf), pResponseBuf);
                                        }
                                        else {
                                            printf("... failed to send response to remote client\r\n");
                                        }

                                        HeapFree(GetProcessHeap(), 0, pResponseBuf);
                                    }
                                    else {
                                        printf("... no data file specified to send back to client. Closing socket\r\n");
                                    }

                                    closesocket(ClientSock);
                                }
                            }
                        }
                    }
                }
            }

            if (dwFileSize) {
                HeapFree(GetProcessHeap(), 0, pFileBuf);
            }
        }
    }

    return 0;
}
