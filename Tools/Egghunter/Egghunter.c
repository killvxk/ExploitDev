#include <Windows.h>
#include <stdio.h>
#include <stdint.h>

#define EGG 0x1122334455667788
#define EGG_SIZE 8

uint8_t *EggHunter() {
	MEMORY_BASIC_INFORMATION Mbi;
	SIZE_T cbRegionSize = 0; // SIZE_T is a ULONG_PTR.
	uint8_t* pEggAddress = NULL;

	for (uint8_t* pBaseAddr = NULL; pEggAddress == NULL; pBaseAddr += cbRegionSize) {
		printf("... querying virtual memory at 0x%p\r\n", pBaseAddr);
		
		if (VirtualQuery(pBaseAddr, &Mbi, sizeof(MEMORY_BASIC_INFORMATION64)) == sizeof(MEMORY_BASIC_INFORMATION64)) {
			cbRegionSize = Mbi.RegionSize;

			if (Mbi.Type == MEM_PRIVATE) {
				if (Mbi.State == MEM_COMMIT) {
					if (Mbi.Protect == PAGE_READWRITE) {
						printf("... region at 0x%p matches scanner criteria (private +RW region of committed virtual memory), scanning...\r\n", pBaseAddr);

						for (uint32_t dwX = 0; dwX < (cbRegionSize - EGG_SIZE); dwX++) {
							if (*(uint64_t*)&pBaseAddr[dwX] == EGG) {
								pEggAddress = (pBaseAddr + dwX);
								printf("... found egg 0x%llx at offset %d of region at 0x%p (absolute address: 0x%p)\r\n", EGG, dwX, pBaseAddr, pEggAddress);
								break;
							}
						}
					}
					else {
						printf("... region at 0x%p is not +RW, skipping.\r\n", pBaseAddr);
					}
				}
				else {
					printf("... region at 0x%p is not committed, skipping.\r\n", pBaseAddr);
				}
			}
			else {
				printf("... region at 0x%p is not private, skipping.\r\n", pBaseAddr);
			}
		}
		else {
			printf("... failed to query virtual memory at 0x%p\r\n", pBaseAddr);
			break;
		}
	}

	return pEggAddress;
}

int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) {
	uint8_t* pTestEggAddress = (uint8_t*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x100);
	memcpy(pTestEggAddress, "\x88\x77\x66\x55\x44\x33\x22\x11", EGG_SIZE);
	printf("... egg placed at 0x%p...\r\n", pTestEggAddress);
	uint8_t* pEggAddress = EggHunter();

	if (pEggAddress != NULL) {
		printf("... successfully found egg 0x%llx at 0x%p\r\n", EGG, pEggAddress);
	}
	else {
		printf("... failed to find egg 0x%llx\r\n", EGG);
	}

	return 0;
}