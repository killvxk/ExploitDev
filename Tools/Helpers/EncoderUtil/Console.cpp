#include "StdAfx.h"

enum class OperationType {
	Invalid = 0,
	Padding,
	Address,
	Unescape,
	Neg,
	JsByteArray,
	Float,
	AsmData,
	AsmDataXor
};

int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) {
	vector<wstring> Args(&pArgv[0], &pArgv[0 + nArgc]);
	shared_ptr<Interface> Intf = make_shared<Interface>(Args);

	if (nArgc < 5) {
		Intf->Log("* Usage: %ws --op <padding|address|unescape|neg|js-dword-array|float|asm-data|asm-data-xor> --ds <data string> --df <data file path> -c <output count> -k <key (hex value)>\r\n", pArgv[0]);
	}
	else {
		OperationType Op = OperationType::Invalid;
		wstring DataStr;
		wstring DataFilePath;
		int32_t nCount = 0;
		uint8_t* Key = 0;

		for (vector<wstring>::const_iterator i = Args.begin(); i != Args.end(); ++i) {
			wstring Arg = *i;
			transform(Arg.begin(), Arg.end(), Arg.begin(), ::tolower);
			
			if (Arg == L"--op") {
				if (*(i + 1) == L"padding") {
					Op = OperationType::Padding;
				}
				else if (*(i + 1) == L"address") {
					Op = OperationType::Address;
				}
				else if (*(i + 1) == L"unescape") {
					Op = OperationType::Unescape;
				}
				else if (*(i + 1) == L"neg") {
					Op = OperationType::Neg;
				}
				else if (*(i + 1) == L"asm-data") {
					Op = OperationType::AsmData;
				}
				else if (*(i + 1) == L"asm-data-xor") {
					Op = OperationType::AsmDataXor;
				}
				else if (*(i + 1) == L"float") {
					Op = OperationType::Float;
				}
				else if (*(i + 1) == L"js-dword-array") {
					Op = OperationType::JsByteArray;
				}
			}
			else if (Arg == L"--ds") {
				DataStr = wstring((*(i + 1)));
			}
			else if (Arg == L"--df") {
				DataFilePath = wstring((*(i + 1)));
			}
			else if (Arg == L"-c") {
				nCount = _wtoi((*(i + 1)).c_str());
			}
			else if (Arg == L"-k") {
				Key = (uint8_t*)wcstoul((*(i + 1)).c_str(), NULL, 0);
			}
		}

		if (Op == OperationType::AsmDataXor) {
			if (Key == 0) {
				Intf->Log("... a key must be specified for ASM data XOR encoding\r\n");
				return 0;
			}
		}

		unique_ptr<uint8_t[]> Data;
		uint32_t dwDataSize = 0;
		uint8_t* pAddress = nullptr;

		if (!DataFilePath.empty()) {
			try {
				FileBase DataFile(DataFilePath);
				dwDataSize = DataFile.GetSize();
				Data = make_unique<uint8_t[]>(DataFile.GetSize());
				memcpy(Data.get(), DataFile.GetData(), DataFile.GetSize());
				
			}
			catch (int32_t nError) {
				//
			}
		}
		else if (!DataStr.empty()) {
			if (Op != OperationType::Float) {
#ifdef _WIN64
				if (wcslen(DataStr.c_str()) == 18) {
					pAddress = (uint8_t*)wcstoull(DataStr.c_str(), NULL, 0);
					dwDataSize = 8;
					Data = make_unique<uint8_t[]>(dwDataSize);
					memcpy(Data.get(), &pAddress, dwDataSize);
				}
				else {
					Intf->Log("... invalid data string (expected a 10 byte 32-bit hex address)\r\n");
				}
#else
				if (wcslen(DataStr.c_str()) == 10) {
					pAddress = (uint8_t*)wcstoul(DataStr.c_str(), NULL, 0);
					dwDataSize = 4;
					Data = make_unique<uint8_t[]>(dwDataSize);
					memcpy(Data.get(), &pAddress, dwDataSize);
				}
				else {
					Intf->Log("... invalid data string (expected a 10 byte 32-bit hex address)\r\n");
				}
#endif
			}
		}

		if (!Data && DataStr.empty()) {
			Intf->Log("... fatal error: no input data specified\r\n");
		}

		if (Op == OperationType::Padding) {
			for (int32_t nX = 0; nX < nCount; nX++) {
				Intf->Log("%ws", DataStr.c_str());
			}
		}
		else if (Op == OperationType::AsmDataXor) {
			uint32_t dwAlignedDataSize;

			Intf->Log("... aligning %d bytes of data to %d byte alignment boundary...\r\n", dwDataSize, sizeof(uint8_t*));
			for (dwAlignedDataSize = dwDataSize; dwAlignedDataSize % sizeof(uint8_t*) != 0; dwAlignedDataSize++);
			Intf->Log("... aligned %d bytes of data to %d bytes. Padding will be filled with 0's\r\n", dwDataSize, dwAlignedDataSize);

			unique_ptr<uint8_t[]> AlignedData = make_unique<uint8_t[]>(dwAlignedDataSize);

			ZeroMemory(AlignedData.get(), dwAlignedDataSize);
			memcpy(AlignedData.get(), Data.get(), dwDataSize);
			
			Intf->Log("... encrypting %d bytes with XOR key 0x%p (%d iterations)\r\n", dwAlignedDataSize, Key, dwAlignedDataSize / sizeof(uint8_t *));
			Intf->Log("Dd ");

			for (int32_t nX = 0; nX < dwAlignedDataSize; nX += 4) {
				Intf->Log("0%08xh, ", *(uint32_t*)&AlignedData[nX] ^ reinterpret_cast<uint32_t>(Key));
			}

			Intf->Log("\r\n");
		}
		else if (Op == OperationType::AsmData) {
			Intf->Log("Db ");
			for (int32_t nX = 0; nX < dwDataSize; nX++) {
				Intf->Log("0%02xh, ", Data[nX]);
			}
			Intf->Log("\r\n");
		}
		else if (Op == OperationType::JsByteArray) {
			Intf->Log("var Shellcode = [ ");

			for (int32_t nX = 0; nX < dwDataSize; nX += 4) {
				Intf->Log("0x%08x, ", *(uint32_t *)&Data[nX]);
			}

			Intf->Log("];");
		}
		else if (Op == OperationType::Neg) {
			uint8_t* pNegValue;
#ifdef _WIN64
			pAddress = (uint8_t*)wcstoull(DataStr.c_str(), NULL, 0);
			dwDataSize = 8;
			pNegValue = (uint8_t*)(-(int64_t)pAddress);
#else
			pAddress = (uint8_t*)wcstoul(DataStr.c_str(), NULL, 0);
			dwDataSize = 4;
			pNegValue = (uint8_t *)(-(int32_t)pAddress);
#endif
			Intf->Log("0x%p", pNegValue);
			Data = make_unique<uint8_t[]>(dwDataSize);
			Op = OperationType::Unescape;
			memcpy(Data.get(), &pNegValue, dwDataSize);
			Intf->Log("\r\n");
		}
		else if (Op == OperationType::Float) {
			if (DataStr.empty()) {
				uint32_t dwOriginalDataSize = dwDataSize;

				for (; dwDataSize % (sizeof(double)) != 0; dwDataSize++);

				if (dwOriginalDataSize != dwDataSize) {
					Intf->Log("... aligned target data size of %d to %d for clean multiple of 8 (double size)\r\n", dwOriginalDataSize, dwDataSize);

					unique_ptr<uint8_t[]> Temp = make_unique<uint8_t[]>(dwDataSize);
					memcpy(Temp.get(), Data.get(), dwOriginalDataSize);
					Data = make_unique<uint8_t[]>(dwDataSize);
					ZeroMemory(Data.get(), dwDataSize);
					memcpy(Data.get(), Temp.get(), dwOriginalDataSize);
				}

				uint32_t dwFloatCount = (dwDataSize / sizeof(double));
				double fData = 0.0;

				for (uint32_t dwX = 0; dwX < dwFloatCount; dwX++) {
					uint8_t* pBuf = (uint8_t*)&fData;

					memcpy(&fData, Data.get() + (dwX * sizeof(double)), sizeof(double));
					Intf->Log("S%d = %e;\r\n", dwX + 1, fData);
					
					for (int32_t nX = 0; nX < sizeof(fData); nX++) {
						Intf->Log(VerbosityLevel::Detail, "x%02x ", pBuf[nX]);
					}

					Intf->Log(VerbosityLevel::Detail, "\r\n");

					wchar_t TestConvert[200] = { 0 }; 
					_snwprintf_s(TestConvert, 200, L"%e", fData);
					Intf->Log("string: %ws\r\n", TestConvert);
				}
			}
			else {
				//double fData = wcstod(DataStr.c_str(), nullptr); // Double is 8 bytes, "long double" (not supported in MSVC) is 16 bytes. Float is 4 bytes. JS uses doubles, as do existing JIT spray float/shellcode converters.
				double fData2 = _wtof(DataStr.c_str());
				double fData = 0.0;
				memcpy(&fData, &fData2, sizeof(double));
				uint8_t* pBuf = (uint8_t*)&fData;

				Intf->Log("%e\r\n", fData);
				
				for (int32_t nX = 0; nX < sizeof(fData); nX++) {
					Intf->Log("x%02x ", pBuf[nX]);
				}
			}
		}
		else if (Op == OperationType::Unescape) {
			if (dwDataSize % 2 != 0) {
				unique_ptr<uint8_t[]> Temp = make_unique<uint8_t[]>(dwDataSize);
				memcpy(Temp.get(), Data.get(), dwDataSize);
				dwDataSize++;
				Data = make_unique<uint8_t[]>(dwDataSize);
				ZeroMemory(Data.get(), dwDataSize);
				memcpy(Data.get(), Temp.get(), dwDataSize);
			}

			Intf->Log("unescape(\"");
			
			for (int32_t nX = 0; nX < dwDataSize; nX += 2) {
				Intf->Log("%%u%02x%02x", Data[nX + 1], Data[nX]);
			}

			Intf->Log("\");");
		}
		else if (Op == OperationType::Address) {
#ifdef _WIN64
			pAddress = (uint8_t*)wcstoull(DataStr.c_str(), NULL, 0);
#else
			pAddress = (uint8_t*)wcstoul(DataStr.c_str(), NULL, 0);
#endif
			uint8_t* pBuf = (uint8_t*)&pAddress;
			for (int32_t nX = 0; nX < sizeof(pAddress); nX++) {
				Intf->Log("\\x%02x", pBuf[nX]);
			}
		}
	}

	return 0;
}