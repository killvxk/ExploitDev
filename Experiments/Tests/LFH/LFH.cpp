#include <Windows.h>
#include <stdio.h>
#include <stdint.h>

bool AllocReClaim(bool bEnableLFH, uint32_t dwAllocCount, uint32_t dwAllocSize) {
	uint8_t** ppAllocArray = new uint8_t* [dwAllocCount];
	srand(GetTickCount());

	for (uint32_t dwX = 0; dwX < 0x12; dwX++) {
		HeapAlloc(GetProcessHeap(), 0, dwAllocSize);
	}

	printf("... allocating %d buffers of size %d\r\n", dwAllocCount, dwAllocSize);

	for (uint32_t dwX = 0; dwX < dwAllocCount; dwX++) {
		ppAllocArray[dwX] = (uint8_t *)HeapAlloc(GetProcessHeap(), 0, dwAllocSize);
		printf("[%d] 0x%p\r\n", dwX, ppAllocArray[dwX]);
	}

	uint32_t dwFreeIndex = (rand() % (dwAllocCount - 1));
	uint8_t* pReClaimAlloc = ppAllocArray[dwFreeIndex];
	uint8_t* pNewAlloc = nullptr;
	HeapFree(GetProcessHeap(), 0, ppAllocArray[dwFreeIndex]);
	printf("... freed allocation at 0x%p (index %d)\r\n", ppAllocArray[dwFreeIndex], dwFreeIndex);

	for (uint32_t dwX = 0; dwX < 10000; dwX++) {
		pNewAlloc = (uint8_t*)HeapAlloc(GetProcessHeap(), 0, dwAllocSize);
		printf("... re-claim attempt %d: 0x%p\r\n", dwX, pNewAlloc);

		if (pNewAlloc == pReClaimAlloc) {
			printf("... re-claim successful.\r\n");
			return true;
		}
	}

	printf("... exceeded max re-claim attempts\r\n");
	return false;
}

int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) {
	// Spray X chunks of X size, free one, and then attempt re-claim
	if (nArgc < 3) {
		printf("... usage: <enable LFH y/n> <alloc count> <alloc size (decimal)>\r\n");
		return 0;
	}

	uint32_t dwAllocCount = _wtoi(pArgv[2]), dwAllocSize = _wtoi(pArgv[3]);
	bool bEnableLFH = false;

	if (pArgv[1][0] == 'y') {
		printf("... LFH will ne enabled.\r\n");
		bEnableLFH = true;
	}
	AllocReClaim(bEnableLFH, dwAllocCount, dwAllocSize);
	return 0;
}